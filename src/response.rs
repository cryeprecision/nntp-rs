use human_repr::HumanCount;
use tokio::io::AsyncBufRead;
use tracing::{Span, field};

use crate::constants::{CRLF, MAX_INITIAL_LINE_LENGTH, RESPONSE_CODE_LENGTH};
use crate::util;

/// <https://datatracker.ietf.org/doc/html/rfc3977.html#section-3.1>
///
/// ```text
/// Each response MUST start with a three-digit response code that is
/// sufficient to distinguish all responses.  Certain valid responses are
/// defined to be multi-line; for all others, the response is contained
/// in a single line.  The initial line of the response MUST NOT exceed
/// 512 octets, which includes the response code and the terminating CRLF
/// pair; an extension MAY specify a greater maximum for commands that it
/// defines, but not for any other command.  Single-line responses
/// consist of an initial line only.  Multi-line responses consist of an
/// initial line followed by a multi-line data block.
/// ```
#[derive(Clone, PartialEq, Eq)]
pub enum Response {
    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 100 (multi-line)
    ///    Generated by: HELP
    ///    Meaning: help text follows.
    /// ```
    HelpText(String),

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 101 (multi-line)
    ///    Generated by: CAPABILITIES
    ///    Meaning: capabilities list follows.
    /// ```
    Capabilities(Vec<String>),

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 111
    ///    Generated by: DATE
    ///    1 argument: yyyymmddhhmmss
    ///    Meaning: server date and time.
    /// ```
    DateTime(chrono::NaiveDateTime),

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 200
    ///    Generated by: initial connection, MODE READER
    ///    Meaning: service available, posting allowed.
    /// ```
    ServiceAvailablePostingAllowed,

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 201
    ///    Generated by: initial connection, MODE READER
    ///    Meaning: service available, posting prohibited.
    /// ```
    ServiceAvailablePostingProhibited,

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    /// ```text
    /// Response code 205
    ///    Generated by: QUIT
    ///    Meaning: connection closing (the server immediately closes the
    ///    connection).
    /// ```
    ConnectionClosing,

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 222 (multi-line)
    ///    Generated by: BODY
    ///    2 arguments: n message-id
    ///    Meaning: article body follows.
    /// ```
    ///
    /// - Article body does not include the terminating dot line
    ArticleBody(Vec<u8>),

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 240
    ///    Generated by: POST (second stage)
    ///    Meaning: article received OK.
    /// ```
    ArticleReceivedOk,

    /// <https://datatracker.ietf.org/doc/html/rfc4643.html#section-4>
    ///
    /// ```text
    /// Response code 281
    ///    Generated by: AUTHINFO USER, AUTHINFO PASS, AUTHINFO SASL
    ///    Meaning: authentication accepted
    /// ```
    AuthenticationAccepted,

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 340
    ///    Generated by: POST (first stage)
    ///    Meaning: send article to be posted.
    /// ```
    SendArticleToBePosted,

    /// <https://datatracker.ietf.org/doc/html/rfc4643.html#section-4>
    ///
    /// ```text
    /// Response code 381
    ///    Generated by: AUTHINFO USER
    ///    Meaning: password required via AUTHINFO PASS command.  Note
    ///    that this code is used for backwards compatibility and does
    ///    not conform to the traditional use of 3xx codes.
    /// ```
    PasswordRequired,

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 400
    ///    Generic response and generated by initial connection
    ///    Meaning: service not available or no longer available (the server
    ///    immediately closes the connection).
    /// ```
    ServiceUnavailable,

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 430
    ///    Generated by: ARTICLE, BODY, HDR, HEAD, OVER, STAT
    ///    Meaning: no article with that message-id.
    /// ```
    MessageIdNotFound,

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 440
    ///    Generated by: POST (first stage)
    ///    Meaning: posting not permitted.
    /// ```
    PostingNotPermitted,

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 441
    ///    Generated by: POST (second stage)
    ///    Meaning: posting failed.
    /// ```
    PostingFailed,

    /// <https://datatracker.ietf.org/doc/html/rfc4643.html#section-4>
    ///
    /// ```text
    /// Response code 481
    ///    Generated by: AUTHINFO USER, AUTHINFO PASS, AUTHINFO SASL
    ///    Meaning: authentication failed/rejected
    /// ```
    AuthenticationRejected,

    /// <https://datatracker.ietf.org/doc/html/rfc4643.html#section-4>
    ///
    /// ```text
    /// Response code 482
    ///    Generated by: AUTHINFO USER, AUTHINFO PASS, AUTHINFO SASL
    ///    Meaning: authentication commands issued out of sequence or
    ///    SASL protocol error
    /// ```
    AuthenticationOutOfSequence,

    /// <https://datatracker.ietf.org/doc/html/rfc3977.html#appendix-C>
    ///
    /// ```text
    /// Response code 502
    ///    Generic response and generated by initial connection
    ///
    ///    Meaning for the initial connection and the MODE READER command:
    ///    service permanently unavailable (the server immediately closes the
    ///    connection).
    ///
    ///    Meaning for all other commands: command not permitted (and there
    ///    is no way for the client to change this).
    /// ```
    CommandUnavailable,
}

impl std::fmt::Debug for Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Response::HelpText(text) => f
                .debug_tuple("HelpText")
                .field(&text.len().human_count_bytes().to_string())
                .finish(),
            Response::Capabilities(lines) => {
                let len = lines
                    .iter()
                    .map(|line| line.len() + CRLF.len())
                    .sum::<usize>();
                f.debug_tuple("Capabilities")
                    .field(&len.human_count_bytes().to_string())
                    .finish()
            }
            Response::DateTime(datetime) => f.debug_tuple("DateTime").field(datetime).finish(),
            Response::ServiceAvailablePostingAllowed => {
                f.debug_tuple("ServiceAvailablePostingAllowed").finish()
            }
            Response::ServiceAvailablePostingProhibited => {
                f.debug_tuple("ServiceAvailablePostingProhibited").finish()
            }
            Response::ConnectionClosing => f.debug_tuple("ConnectionClosing").finish(),
            Response::ArticleBody(body) => f
                .debug_tuple("ArticleBody")
                .field(&body.len().human_count_bytes().to_string())
                .finish(),
            Response::ArticleReceivedOk => f.debug_tuple("ArticleReceivedOk").finish(),
            Response::AuthenticationAccepted => f.debug_tuple("AuthenticationAccepted").finish(),
            Response::SendArticleToBePosted => f.debug_tuple("SendArticleToBePosted").finish(),
            Response::PasswordRequired => f.debug_tuple("PasswordRequired").finish(),
            Response::ServiceUnavailable => f.debug_tuple("ServiceUnavailable").finish(),
            Response::MessageIdNotFound => f.debug_tuple("MessageIdNotFound").finish(),
            Response::PostingNotPermitted => f.debug_tuple("PostingNotPermitted").finish(),
            Response::PostingFailed => f.debug_tuple("PostingFailed").finish(),
            Response::AuthenticationRejected => f.debug_tuple("AuthenticationRejected").finish(),
            Response::AuthenticationOutOfSequence => {
                f.debug_tuple("AuthenticationOutOfSequence").finish()
            }
            Response::CommandUnavailable => f.debug_tuple("CommandUnavailable").finish(),
        }
    }
}

impl Response {
    #[tracing::instrument(level = "debug", skip(reader), fields(response))]
    pub async fn read_response<R: AsyncBufRead + Unpin>(
        reader: &mut R,
    ) -> Result<Self, std::io::Error> {
        let mut buffer = Vec::with_capacity(MAX_INITIAL_LINE_LENGTH);

        // Read the initial response line
        let read = util::read_initial_line(reader, &mut buffer).await?;
        if read < RESPONSE_CODE_LENGTH {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Response line too short to contain a response code",
            ));
        }

        // Parse the response code and maybe additional text
        let (code, rest) = buffer.split_at(RESPONSE_CODE_LENGTH);
        let code = std::str::from_utf8(code)
            .map_err(|_| {
                std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    "Response code is not valid UTF-8",
                )
            })?
            .parse::<u16>()
            .map_err(|_| {
                std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    "Response code is not a number",
                )
            })?;
        let rest = str::from_utf8(rest)
            .map_err(|_| {
                std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    "Additional response text is not valid UTF-8",
                )
            })?
            .trim();
        let rest = (!rest.is_empty()).then(|| rest.to_string());

        tracing::trace!("Received NNTP response initial line: {code} {rest:?}");

        // Handle the remaining response based on the code
        // TODO: Responses with `123 <arg> <extra-text>` format are not handled yet
        buffer.clear();
        let response = match code {
            100 => {
                util::read_multi_line_data_block(reader, &mut buffer).await?;
                let help_text = str::from_utf8(&buffer)
                    .map_err(|_| {
                        std::io::Error::new(
                            std::io::ErrorKind::InvalidData,
                            "Help text is not valid UTF-8",
                        )
                    })?
                    .trim()
                    .to_string();
                Ok(Response::HelpText(help_text))
            }
            101 => {
                util::read_multi_line_data_block(reader, &mut buffer).await?;
                let capabilities = str::from_utf8(&buffer)
                    .map_err(|_| {
                        std::io::Error::new(
                            std::io::ErrorKind::InvalidData,
                            "Capabilities list is not valid UTF-8",
                        )
                    })?
                    .lines()
                    .map(|line| line.to_string())
                    .collect();
                Ok(Response::Capabilities(capabilities))
            }
            111 => {
                let rest = rest.as_deref().ok_or_else(|| {
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        "Datetime response missing argument",
                    )
                })?;
                let datetime = chrono::NaiveDateTime::parse_from_str(rest, "%Y%m%d%H%M%S")
                    .map_err(|_| {
                        std::io::Error::new(
                            std::io::ErrorKind::InvalidData,
                            "Datetime response argument has invalid format",
                        )
                    })?;
                Ok(Response::DateTime(datetime))
            }
            200 => Ok(Response::ServiceAvailablePostingAllowed),
            201 => Ok(Response::ServiceAvailablePostingProhibited),
            205 => Ok(Response::ConnectionClosing),
            222 => {
                util::read_multi_line_data_block(reader, &mut buffer).await?;
                Ok(Response::ArticleBody(buffer))
            }
            240 => Ok(Response::ArticleReceivedOk),
            281 => Ok(Response::AuthenticationAccepted),
            340 => Ok(Response::SendArticleToBePosted),
            381 => Ok(Response::PasswordRequired),
            400 => Ok(Response::ServiceUnavailable),
            430 => Ok(Response::MessageIdNotFound),
            440 => Ok(Response::PostingNotPermitted),
            441 => Ok(Response::PostingFailed),
            481 => Ok(Response::AuthenticationRejected),
            482 => Ok(Response::AuthenticationOutOfSequence),
            502 => Ok(Response::CommandUnavailable),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("Unknown NNTP response code: {}", code),
            )),
        };

        Span::current().record("response", field::debug(&response));
        response
    }
}
